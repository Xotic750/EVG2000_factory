/* parser auto-generated by pidl */

#include "includes.h"
#include "librpc/gen_ndr/ndr_drsblobs.h"

#include "librpc/gen_ndr/ndr_drsuapi.h"
#include "librpc/gen_ndr/ndr_misc.h"
static enum ndr_err_code ndr_push_replPropertyMetaData1(struct ndr_push *ndr, int ndr_flags, const struct replPropertyMetaData1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_drsuapi_DsAttributeId(ndr, NDR_SCALARS, r->attid));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->originating_change_time));
		NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->originating_invocation_id));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->originating_usn));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->local_usn));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replPropertyMetaData1(struct ndr_pull *ndr, int ndr_flags, struct replPropertyMetaData1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_drsuapi_DsAttributeId(ndr, NDR_SCALARS, &r->attid));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->originating_change_time));
		NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->originating_invocation_id));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->originating_usn));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->local_usn));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replPropertyMetaData1(struct ndr_print *ndr, const char *name, const struct replPropertyMetaData1 *r)
{
	ndr_print_struct(ndr, name, "replPropertyMetaData1");
	ndr->depth++;
	ndr_print_drsuapi_DsAttributeId(ndr, "attid", r->attid);
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_NTTIME_1sec(ndr, "originating_change_time", r->originating_change_time);
	ndr_print_GUID(ndr, "originating_invocation_id", &r->originating_invocation_id);
	ndr_print_hyper(ndr, "originating_usn", r->originating_usn);
	ndr_print_hyper(ndr, "local_usn", r->local_usn);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replPropertyMetaDataCtr1(struct ndr_push *ndr, int ndr_flags, const struct replPropertyMetaDataCtr1 *r)
{
	uint32_t cntr_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_push_replPropertyMetaData1(ndr, NDR_SCALARS, &r->array[cntr_array_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replPropertyMetaDataCtr1(struct ndr_pull *ndr, int ndr_flags, struct replPropertyMetaDataCtr1 *r)
{
	uint32_t cntr_array_0;
	TALLOC_CTX *_mem_save_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_PULL_ALLOC_N(ndr, r->array, r->count);
		_mem_save_array_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->array, 0);
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_pull_replPropertyMetaData1(ndr, NDR_SCALARS, &r->array[cntr_array_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_array_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replPropertyMetaDataCtr1(struct ndr_print *ndr, const char *name, const struct replPropertyMetaDataCtr1 *r)
{
	uint32_t cntr_array_0;
	ndr_print_struct(ndr, name, "replPropertyMetaDataCtr1");
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "array", (int)r->count);
	ndr->depth++;
	for (cntr_array_0=0;cntr_array_0<r->count;cntr_array_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_array_0) != -1) {
			ndr_print_replPropertyMetaData1(ndr, "array", &r->array[cntr_array_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replPropertyMetaDataCtr(struct ndr_push *ndr, int ndr_flags, const union replPropertyMetaDataCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_replPropertyMetaDataCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replPropertyMetaDataCtr(struct ndr_pull *ndr, int ndr_flags, union replPropertyMetaDataCtr *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_replPropertyMetaDataCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replPropertyMetaDataCtr(struct ndr_print *ndr, const char *name, const union replPropertyMetaDataCtr *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "replPropertyMetaDataCtr");
	switch (level) {
		case 1:
			ndr_print_replPropertyMetaDataCtr1(ndr, "ctr1", &r->ctr1);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_replPropertyMetaDataBlob(struct ndr_push *ndr, int ndr_flags, const struct replPropertyMetaDataBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_replPropertyMetaDataCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_replPropertyMetaDataBlob(struct ndr_pull *ndr, int ndr_flags, struct replPropertyMetaDataBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_replPropertyMetaDataCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replPropertyMetaDataBlob(struct ndr_print *ndr, const char *name, const struct replPropertyMetaDataBlob *r)
{
	ndr_print_struct(ndr, name, "replPropertyMetaDataBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_replPropertyMetaDataCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replUpToDateVectorCtr1(struct ndr_push *ndr, int ndr_flags, const struct replUpToDateVectorCtr1 *r)
{
	uint32_t cntr_cursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		for (cntr_cursors_0 = 0; cntr_cursors_0 < r->count; cntr_cursors_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsReplicaCursor(ndr, NDR_SCALARS, &r->cursors[cntr_cursors_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replUpToDateVectorCtr1(struct ndr_pull *ndr, int ndr_flags, struct replUpToDateVectorCtr1 *r)
{
	uint32_t cntr_cursors_0;
	TALLOC_CTX *_mem_save_cursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_PULL_ALLOC_N(ndr, r->cursors, r->count);
		_mem_save_cursors_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->cursors, 0);
		for (cntr_cursors_0 = 0; cntr_cursors_0 < r->count; cntr_cursors_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaCursor(ndr, NDR_SCALARS, &r->cursors[cntr_cursors_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_cursors_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replUpToDateVectorCtr1(struct ndr_print *ndr, const char *name, const struct replUpToDateVectorCtr1 *r)
{
	uint32_t cntr_cursors_0;
	ndr_print_struct(ndr, name, "replUpToDateVectorCtr1");
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "cursors", (int)r->count);
	ndr->depth++;
	for (cntr_cursors_0=0;cntr_cursors_0<r->count;cntr_cursors_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_cursors_0) != -1) {
			ndr_print_drsuapi_DsReplicaCursor(ndr, "cursors", &r->cursors[cntr_cursors_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replUpToDateVectorCtr2(struct ndr_push *ndr, int ndr_flags, const struct replUpToDateVectorCtr2 *r)
{
	uint32_t cntr_cursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		for (cntr_cursors_0 = 0; cntr_cursors_0 < r->count; cntr_cursors_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsReplicaCursor2(ndr, NDR_SCALARS, &r->cursors[cntr_cursors_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replUpToDateVectorCtr2(struct ndr_pull *ndr, int ndr_flags, struct replUpToDateVectorCtr2 *r)
{
	uint32_t cntr_cursors_0;
	TALLOC_CTX *_mem_save_cursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_PULL_ALLOC_N(ndr, r->cursors, r->count);
		_mem_save_cursors_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->cursors, 0);
		for (cntr_cursors_0 = 0; cntr_cursors_0 < r->count; cntr_cursors_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaCursor2(ndr, NDR_SCALARS, &r->cursors[cntr_cursors_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_cursors_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replUpToDateVectorCtr2(struct ndr_print *ndr, const char *name, const struct replUpToDateVectorCtr2 *r)
{
	uint32_t cntr_cursors_0;
	ndr_print_struct(ndr, name, "replUpToDateVectorCtr2");
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "cursors", (int)r->count);
	ndr->depth++;
	for (cntr_cursors_0=0;cntr_cursors_0<r->count;cntr_cursors_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_cursors_0) != -1) {
			ndr_print_drsuapi_DsReplicaCursor2(ndr, "cursors", &r->cursors[cntr_cursors_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replUpToDateVectorCtr(struct ndr_push *ndr, int ndr_flags, const union replUpToDateVectorCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_replUpToDateVectorCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_push_replUpToDateVectorCtr2(ndr, NDR_SCALARS, &r->ctr2));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
			break;

			case 2:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replUpToDateVectorCtr(struct ndr_pull *ndr, int ndr_flags, union replUpToDateVectorCtr *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_replUpToDateVectorCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_pull_replUpToDateVectorCtr2(ndr, NDR_SCALARS, &r->ctr2));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
			break;

			case 2:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replUpToDateVectorCtr(struct ndr_print *ndr, const char *name, const union replUpToDateVectorCtr *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "replUpToDateVectorCtr");
	switch (level) {
		case 1:
			ndr_print_replUpToDateVectorCtr1(ndr, "ctr1", &r->ctr1);
		break;

		case 2:
			ndr_print_replUpToDateVectorCtr2(ndr, "ctr2", &r->ctr2);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_replUpToDateVectorBlob(struct ndr_push *ndr, int ndr_flags, const struct replUpToDateVectorBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_replUpToDateVectorCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_replUpToDateVectorBlob(struct ndr_pull *ndr, int ndr_flags, struct replUpToDateVectorBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_replUpToDateVectorCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replUpToDateVectorBlob(struct ndr_print *ndr, const char *name, const struct replUpToDateVectorBlob *r)
{
	ndr_print_struct(ndr, name, "replUpToDateVectorBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_replUpToDateVectorCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_repsFromTo1OtherInfo(struct ndr_push *ndr, int ndr_flags, const struct repsFromTo1OtherInfo *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, strlen(r->dns_name) + 1));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->dns_name, strlen(r->dns_name) + 1, sizeof(uint8_t), CH_DOS));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_repsFromTo1OtherInfo(struct ndr_pull *ndr, int ndr_flags, struct repsFromTo1OtherInfo *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->__dns_name_size));
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->dns_name, r->__dns_name_size, sizeof(uint8_t), CH_DOS));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromTo1OtherInfo(struct ndr_print *ndr, const char *name, const struct repsFromTo1OtherInfo *r)
{
	ndr_print_struct(ndr, name, "repsFromTo1OtherInfo");
	ndr->depth++;
	ndr_print_uint32(ndr, "__dns_name_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?strlen(r->dns_name) + 1:r->__dns_name_size);
	ndr_print_string(ndr, "dns_name", r->dns_name);
	ndr->depth--;
}

_PUBLIC_ size_t ndr_size_repsFromTo1OtherInfo(const struct repsFromTo1OtherInfo *r, int flags)
{
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_repsFromTo1OtherInfo);
}

_PUBLIC_ enum ndr_err_code ndr_push_repsFromTo1(struct ndr_push *ndr, int ndr_flags, const struct repsFromTo1 *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 8));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_repsFromTo1(r, ndr->flags) + 8));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->consecutive_sync_failures));
			NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->last_success));
			NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->last_attempt));
			NDR_CHECK(ndr_push_WERROR(ndr, NDR_SCALARS, r->result_last_attempt));
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->other_info));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_repsFromTo1OtherInfo(r->other_info, ndr->flags)));
			NDR_CHECK(ndr_push_drsuapi_DsReplicaNeighbourFlags(ndr, NDR_SCALARS, r->replica_flags));
			NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->schedule, 84));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
			NDR_CHECK(ndr_push_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->transport_guid));
		}
		if (ndr_flags & NDR_BUFFERS) {
			if (r->other_info) {
				NDR_CHECK(ndr_push_relative_ptr2(ndr, r->other_info));
				NDR_CHECK(ndr_push_repsFromTo1OtherInfo(ndr, NDR_SCALARS, r->other_info));
			}
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_repsFromTo1(struct ndr_pull *ndr, int ndr_flags, struct repsFromTo1 *r)
{
	uint32_t _ptr_other_info;
	TALLOC_CTX *_mem_save_other_info_0;
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 8));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->blobsize));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->consecutive_sync_failures));
			NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->last_success));
			NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->last_attempt));
			NDR_CHECK(ndr_pull_WERROR(ndr, NDR_SCALARS, &r->result_last_attempt));
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_other_info));
			if (_ptr_other_info) {
				NDR_PULL_ALLOC(ndr, r->other_info);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->other_info, _ptr_other_info));
			} else {
				r->other_info = NULL;
			}
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->other_info_length));
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaNeighbourFlags(ndr, NDR_SCALARS, &r->replica_flags));
			NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->schedule, 84));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->transport_guid));
		}
		if (ndr_flags & NDR_BUFFERS) {
			if (r->other_info) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->other_info));
				_mem_save_other_info_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->other_info, 0);
				NDR_CHECK(ndr_pull_repsFromTo1OtherInfo(ndr, NDR_SCALARS, r->other_info));
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_other_info_0, 0);
				ndr->offset = _relative_save_offset;
			}
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromTo1(struct ndr_print *ndr, const char *name, const struct repsFromTo1 *r)
{
	ndr_print_struct(ndr, name, "repsFromTo1");
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		ndr->depth++;
		ndr_print_uint32(ndr, "blobsize", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_repsFromTo1(r, ndr->flags) + 8:r->blobsize);
		ndr_print_uint32(ndr, "consecutive_sync_failures", r->consecutive_sync_failures);
		ndr_print_NTTIME_1sec(ndr, "last_success", r->last_success);
		ndr_print_NTTIME_1sec(ndr, "last_attempt", r->last_attempt);
		ndr_print_WERROR(ndr, "result_last_attempt", r->result_last_attempt);
		ndr_print_ptr(ndr, "other_info", r->other_info);
		ndr->depth++;
		if (r->other_info) {
			ndr_print_repsFromTo1OtherInfo(ndr, "other_info", r->other_info);
		}
		ndr->depth--;
		ndr_print_uint32(ndr, "other_info_length", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_repsFromTo1OtherInfo(r->other_info, ndr->flags):r->other_info_length);
		ndr_print_drsuapi_DsReplicaNeighbourFlags(ndr, "replica_flags", r->replica_flags);
		ndr_print_array_uint8(ndr, "schedule", r->schedule, 84);
		ndr_print_uint32(ndr, "reserved", r->reserved);
		ndr_print_drsuapi_DsReplicaHighWaterMark(ndr, "highwatermark", &r->highwatermark);
		ndr_print_GUID(ndr, "source_dsa_obj_guid", &r->source_dsa_obj_guid);
		ndr_print_GUID(ndr, "source_dsa_invocation_id", &r->source_dsa_invocation_id);
		ndr_print_GUID(ndr, "transport_guid", &r->transport_guid);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

_PUBLIC_ size_t ndr_size_repsFromTo1(const struct repsFromTo1 *r, int flags)
{
	flags |= LIBNDR_PRINT_ARRAY_HEX;
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_repsFromTo1);
}

static enum ndr_err_code ndr_push_repsFromTo(struct ndr_push *ndr, int ndr_flags, const union repsFromTo *r)
{
	if (ndr_flags & NDR_SCALARS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_repsFromTo1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
				NDR_CHECK(ndr_push_repsFromTo1(ndr, NDR_BUFFERS, &r->ctr1));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_repsFromTo(struct ndr_pull *ndr, int ndr_flags, union repsFromTo *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_repsFromTo1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
				NDR_CHECK(ndr_pull_repsFromTo1(ndr, NDR_BUFFERS, &r->ctr1));
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromTo(struct ndr_print *ndr, const char *name, const union repsFromTo *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "repsFromTo");
	switch (level) {
		case 1:
			ndr_print_repsFromTo1(ndr, "ctr1", &r->ctr1);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_repsFromToBlob(struct ndr_push *ndr, int ndr_flags, const struct repsFromToBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_repsFromTo(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_repsFromTo(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_repsFromToBlob(struct ndr_pull *ndr, int ndr_flags, struct repsFromToBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_repsFromTo(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_repsFromTo(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromToBlob(struct ndr_print *ndr, const char *name, const struct repsFromToBlob *r)
{
	ndr_print_struct(ndr, name, "repsFromToBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_repsFromTo(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_partialAttributeSetCtr1(struct ndr_push *ndr, int ndr_flags, const struct partialAttributeSetCtr1 *r)
{
	uint32_t cntr_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsAttributeId(ndr, NDR_SCALARS, r->array[cntr_array_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_partialAttributeSetCtr1(struct ndr_pull *ndr, int ndr_flags, struct partialAttributeSetCtr1 *r)
{
	uint32_t cntr_array_0;
	TALLOC_CTX *_mem_save_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_PULL_ALLOC_N(ndr, r->array, r->count);
		_mem_save_array_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->array, 0);
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsAttributeId(ndr, NDR_SCALARS, &r->array[cntr_array_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_array_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_partialAttributeSetCtr1(struct ndr_print *ndr, const char *name, const struct partialAttributeSetCtr1 *r)
{
	uint32_t cntr_array_0;
	ndr_print_struct(ndr, name, "partialAttributeSetCtr1");
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr->print(ndr, "%s: ARRAY(%d)", "array", (int)r->count);
	ndr->depth++;
	for (cntr_array_0=0;cntr_array_0<r->count;cntr_array_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_array_0) != -1) {
			ndr_print_drsuapi_DsAttributeId(ndr, "array", r->array[cntr_array_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_partialAttributeSetCtr(struct ndr_push *ndr, int ndr_flags, const union partialAttributeSetCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_partialAttributeSetCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_partialAttributeSetCtr(struct ndr_pull *ndr, int ndr_flags, union partialAttributeSetCtr *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_partialAttributeSetCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_partialAttributeSetCtr(struct ndr_print *ndr, const char *name, const union partialAttributeSetCtr *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "partialAttributeSetCtr");
	switch (level) {
		case 1:
			ndr_print_partialAttributeSetCtr1(ndr, "ctr1", &r->ctr1);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_partialAttributeSetBlob(struct ndr_push *ndr, int ndr_flags, const struct partialAttributeSetBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_partialAttributeSetCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_partialAttributeSetBlob(struct ndr_pull *ndr, int ndr_flags, struct partialAttributeSetBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_partialAttributeSetCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_partialAttributeSetBlob(struct ndr_print *ndr, const char *name, const struct partialAttributeSetBlob *r)
{
	ndr_print_struct(ndr, name, "partialAttributeSetBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_partialAttributeSetCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_prefixMapVersion(struct ndr_push *ndr, int ndr_flags, enum prefixMapVersion r)
{
	NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_prefixMapVersion(struct ndr_pull *ndr, int ndr_flags, enum prefixMapVersion *r)
{
	uint32_t v;
	NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_prefixMapVersion(struct ndr_print *ndr, const char *name, enum prefixMapVersion r)
{
	const char *val = NULL;

	switch (r) {
		case PREFIX_MAP_VERSION_DSDB: val = "PREFIX_MAP_VERSION_DSDB"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_prefixMapCtr(struct ndr_push *ndr, int ndr_flags, const union prefixMapCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case PREFIX_MAP_VERSION_DSDB: {
				NDR_CHECK(ndr_push_drsuapi_DsReplicaOIDMapping_Ctr(ndr, NDR_SCALARS, &r->dsdb));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case PREFIX_MAP_VERSION_DSDB:
				NDR_CHECK(ndr_push_drsuapi_DsReplicaOIDMapping_Ctr(ndr, NDR_BUFFERS, &r->dsdb));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_prefixMapCtr(struct ndr_pull *ndr, int ndr_flags, union prefixMapCtr *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case PREFIX_MAP_VERSION_DSDB: {
				NDR_CHECK(ndr_pull_drsuapi_DsReplicaOIDMapping_Ctr(ndr, NDR_SCALARS, &r->dsdb));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case PREFIX_MAP_VERSION_DSDB:
				NDR_CHECK(ndr_pull_drsuapi_DsReplicaOIDMapping_Ctr(ndr, NDR_BUFFERS, &r->dsdb));
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_prefixMapCtr(struct ndr_print *ndr, const char *name, const union prefixMapCtr *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "prefixMapCtr");
	switch (level) {
		case PREFIX_MAP_VERSION_DSDB:
			ndr_print_drsuapi_DsReplicaOIDMapping_Ctr(ndr, "dsdb", &r->dsdb);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_prefixMapBlob(struct ndr_push *ndr, int ndr_flags, const struct prefixMapBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_prefixMapVersion(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_prefixMapCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_prefixMapCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_prefixMapBlob(struct ndr_pull *ndr, int ndr_flags, struct prefixMapBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_prefixMapVersion(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_prefixMapCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_prefixMapCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_prefixMapBlob(struct ndr_print *ndr, const char *name, const struct prefixMapBlob *r)
{
	ndr_print_struct(ndr, name, "prefixMapBlob");
	ndr->depth++;
	ndr_print_prefixMapVersion(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_prefixMapCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ldapControlDirSyncExtra(struct ndr_push *ndr, int ndr_flags, const union ldapControlDirSyncExtra *r)
{
	if (ndr_flags & NDR_SCALARS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 0: {
			break; }

			default: {
				NDR_CHECK(ndr_push_replUpToDateVectorBlob(ndr, NDR_SCALARS, &r->uptodateness_vector));
			break; }

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 0:
			break;

			default:
			break;

		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ldapControlDirSyncExtra(struct ndr_pull *ndr, int ndr_flags, union ldapControlDirSyncExtra *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 0: {
			break; }

			default: {
				NDR_CHECK(ndr_pull_replUpToDateVectorBlob(ndr, NDR_SCALARS, &r->uptodateness_vector));
			break; }

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 0:
			break;

			default:
			break;

		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncExtra(struct ndr_print *ndr, const char *name, const union ldapControlDirSyncExtra *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "ldapControlDirSyncExtra");
	switch (level) {
		case 0:
		break;

		default:
			ndr_print_replUpToDateVectorBlob(ndr, "uptodateness_vector", &r->uptodateness_vector);
		break;

	}
}

static size_t ndr_size_ldapControlDirSyncExtra(const union ldapControlDirSyncExtra *r, uint32_t level, int flags)
{
	return ndr_size_union(r, flags, level, (ndr_push_flags_fn_t)ndr_push_ldapControlDirSyncExtra);
}

static enum ndr_err_code ndr_push_ldapControlDirSyncBlob(struct ndr_push *ndr, int ndr_flags, const struct ldapControlDirSyncBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 3));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->time));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->u2));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->u3));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_ldapControlDirSyncExtra(&r->extra, r->extra.uptodateness_vector.version, 0)));
		NDR_CHECK(ndr_push_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
		NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->guid1));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->extra, ndr_size_ldapControlDirSyncExtra(&r->extra, r->extra.uptodateness_vector.version, 0)));
		NDR_CHECK(ndr_push_ldapControlDirSyncExtra(ndr, NDR_SCALARS, &r->extra));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_ldapControlDirSyncExtra(ndr, NDR_BUFFERS, &r->extra));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ldapControlDirSyncBlob(struct ndr_pull *ndr, int ndr_flags, struct ldapControlDirSyncBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->u1));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->time));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->u2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->u3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->extra_length));
		NDR_CHECK(ndr_pull_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
		NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->guid1));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->extra, r->extra_length));
		NDR_CHECK(ndr_pull_ldapControlDirSyncExtra(ndr, NDR_SCALARS, &r->extra));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_ldapControlDirSyncExtra(ndr, NDR_BUFFERS, &r->extra));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncBlob(struct ndr_print *ndr, const char *name, const struct ldapControlDirSyncBlob *r)
{
	ndr_print_struct(ndr, name, "ldapControlDirSyncBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "u1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?3:r->u1);
	ndr_print_NTTIME(ndr, "time", r->time);
	ndr_print_uint32(ndr, "u2", r->u2);
	ndr_print_uint32(ndr, "u3", r->u3);
	ndr_print_uint32(ndr, "extra_length", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_ldapControlDirSyncExtra(&r->extra, r->extra.uptodateness_vector.version, 0):r->extra_length);
	ndr_print_drsuapi_DsReplicaHighWaterMark(ndr, "highwatermark", &r->highwatermark);
	ndr_print_GUID(ndr, "guid1", &r->guid1);
	ndr_print_set_switch_value(ndr, &r->extra, r->extra_length);
	ndr_print_ldapControlDirSyncExtra(ndr, "extra", &r->extra);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_ldapControlDirSyncCookie(struct ndr_push *ndr, int ndr_flags, const struct ldapControlDirSyncCookie *r)
{
	uint32_t _save_relative_base_offset = ndr_push_get_relative_base_offset(ndr);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_setup_relative_base_offset1(ndr, r, ndr->offset));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, "MSDS", 4, sizeof(uint8_t), CH_DOS));
		{
			struct ndr_push *_ndr_blob;
			NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_blob, 0, -1));
			NDR_CHECK(ndr_push_ldapControlDirSyncBlob(_ndr_blob, NDR_SCALARS|NDR_BUFFERS, &r->blob));
			NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_blob, 0, -1));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_setup_relative_base_offset2(ndr, r));
	}
	ndr_push_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_ldapControlDirSyncCookie(struct ndr_pull *ndr, int ndr_flags, struct ldapControlDirSyncCookie *r)
{
	uint32_t _save_relative_base_offset = ndr_pull_get_relative_base_offset(ndr);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_setup_relative_base_offset1(ndr, r, ndr->offset));
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->msds, 4, sizeof(uint8_t), CH_DOS));
		{
			struct ndr_pull *_ndr_blob;
			NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_blob, 0, -1));
			NDR_CHECK(ndr_pull_ldapControlDirSyncBlob(_ndr_blob, NDR_SCALARS|NDR_BUFFERS, &r->blob));
			NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_blob, 0, -1));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_setup_relative_base_offset2(ndr, r));
	}
	ndr_pull_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncCookie(struct ndr_print *ndr, const char *name, const struct ldapControlDirSyncCookie *r)
{
	ndr_print_struct(ndr, name, "ldapControlDirSyncCookie");
	ndr->depth++;
	ndr_print_string(ndr, "msds", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?"MSDS":r->msds);
	ndr_print_ldapControlDirSyncBlob(ndr, "blob", &r->blob);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_supplementalCredentialsPackage(struct ndr_push *ndr, int ndr_flags, const struct supplementalCredentialsPackage *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 2));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 2 * strlen_m(r->name)));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, strlen(r->data)));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->name, 2 * strlen_m(r->name), sizeof(uint8_t), CH_UTF16));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->data, strlen(r->data), sizeof(uint8_t), CH_DOS));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_supplementalCredentialsPackage(struct ndr_pull *ndr, int ndr_flags, struct supplementalCredentialsPackage *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 2));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->name_len));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->data_len));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->name, r->name_len, sizeof(uint8_t), CH_UTF16));
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->data, r->data_len, sizeof(uint8_t), CH_DOS));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_supplementalCredentialsPackage(struct ndr_print *ndr, const char *name, const struct supplementalCredentialsPackage *r)
{
	ndr_print_struct(ndr, name, "supplementalCredentialsPackage");
	ndr->depth++;
	ndr_print_uint16(ndr, "name_len", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?2 * strlen_m(r->name):r->name_len);
	ndr_print_uint16(ndr, "data_len", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?strlen(r->data):r->data_len);
	ndr_print_uint16(ndr, "reserved", r->reserved);
	ndr_print_string(ndr, "name", r->name);
	ndr_print_string(ndr, "data", r->data);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_supplementalCredentialsSignature(struct ndr_push *ndr, int ndr_flags, enum supplementalCredentialsSignature r)
{
	{
		uint32_t _flags_save_ENUM = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r));
		ndr->flags = _flags_save_ENUM;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_supplementalCredentialsSignature(struct ndr_pull *ndr, int ndr_flags, enum supplementalCredentialsSignature *r)
{
	uint16_t v;
	{
		uint32_t _flags_save_ENUM = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &v));
		*r = v;
		ndr->flags = _flags_save_ENUM;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_supplementalCredentialsSignature(struct ndr_print *ndr, const char *name, enum supplementalCredentialsSignature r)
{
	const char *val = NULL;

	{
		uint32_t _flags_save_ENUM = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		switch (r) {
			case SUPPLEMENTAL_CREDENTIALS_SIGNATURE: val = "SUPPLEMENTAL_CREDENTIALS_SIGNATURE"; break;
		}
		ndr_print_enum(ndr, name, "ENUM", val, r);
		ndr->flags = _flags_save_ENUM;
	}
}

static enum ndr_err_code ndr_push_supplementalCredentialsSubBlob(struct ndr_push *ndr, int ndr_flags, const struct supplementalCredentialsSubBlob *r)
{
	uint32_t cntr_packages_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 2));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, SUPPLEMENTAL_CREDENTIALS_PREFIX, 0x30, sizeof(uint16_t), CH_UTF16));
		NDR_CHECK(ndr_push_supplementalCredentialsSignature(ndr, NDR_SCALARS, SUPPLEMENTAL_CREDENTIALS_SIGNATURE));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_packages));
		for (cntr_packages_0 = 0; cntr_packages_0 < r->num_packages; cntr_packages_0++) {
			NDR_CHECK(ndr_push_supplementalCredentialsPackage(ndr, NDR_SCALARS, &r->packages[cntr_packages_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_supplementalCredentialsSubBlob(struct ndr_pull *ndr, int ndr_flags, struct supplementalCredentialsSubBlob *r)
{
	uint32_t cntr_packages_0;
	TALLOC_CTX *_mem_save_packages_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 2));
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->prefix, 0x30, sizeof(uint16_t), CH_UTF16));
		NDR_CHECK(ndr_pull_supplementalCredentialsSignature(ndr, NDR_SCALARS, &r->signature));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_packages));
		NDR_PULL_ALLOC_N(ndr, r->packages, r->num_packages);
		_mem_save_packages_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->packages, 0);
		for (cntr_packages_0 = 0; cntr_packages_0 < r->num_packages; cntr_packages_0++) {
			NDR_CHECK(ndr_pull_supplementalCredentialsPackage(ndr, NDR_SCALARS, &r->packages[cntr_packages_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_packages_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_supplementalCredentialsSubBlob(struct ndr_print *ndr, const char *name, const struct supplementalCredentialsSubBlob *r)
{
	uint32_t cntr_packages_0;
	ndr_print_struct(ndr, name, "supplementalCredentialsSubBlob");
	ndr->depth++;
	ndr_print_string(ndr, "prefix", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?SUPPLEMENTAL_CREDENTIALS_PREFIX:r->prefix);
	ndr_print_supplementalCredentialsSignature(ndr, "signature", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?SUPPLEMENTAL_CREDENTIALS_SIGNATURE:r->signature);
	ndr_print_uint16(ndr, "num_packages", r->num_packages);
	ndr->print(ndr, "%s: ARRAY(%d)", "packages", (int)r->num_packages);
	ndr->depth++;
	for (cntr_packages_0=0;cntr_packages_0<r->num_packages;cntr_packages_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_packages_0) != -1) {
			ndr_print_supplementalCredentialsPackage(ndr, "packages", &r->packages[cntr_packages_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static size_t ndr_size_supplementalCredentialsSubBlob(const struct supplementalCredentialsSubBlob *r, int flags)
{
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_supplementalCredentialsSubBlob);
}

_PUBLIC_ enum ndr_err_code ndr_push_supplementalCredentialsBlob(struct ndr_push *ndr, int ndr_flags, const struct supplementalCredentialsBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_supplementalCredentialsSubBlob(&r->sub, ndr->flags)));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		{
			struct ndr_push *_ndr_sub;
			NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_sub, 0, ndr_size_supplementalCredentialsSubBlob(&r->sub, ndr->flags)));
			NDR_CHECK(ndr_push_supplementalCredentialsSubBlob(_ndr_sub, NDR_SCALARS, &r->sub));
			NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_sub, 0, ndr_size_supplementalCredentialsSubBlob(&r->sub, ndr->flags)));
		}
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, 0));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_supplementalCredentialsBlob(struct ndr_pull *ndr, int ndr_flags, struct supplementalCredentialsBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown1));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->__ndr_size));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown2));
		{
			struct ndr_pull *_ndr_sub;
			NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_sub, 0, r->__ndr_size));
			NDR_CHECK(ndr_pull_supplementalCredentialsSubBlob(_ndr_sub, NDR_SCALARS, &r->sub));
			NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_sub, 0, r->__ndr_size));
		}
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->unknown3));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_supplementalCredentialsBlob(struct ndr_print *ndr, const char *name, const struct supplementalCredentialsBlob *r)
{
	ndr_print_struct(ndr, name, "supplementalCredentialsBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "unknown1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->unknown1);
	ndr_print_uint32(ndr, "__ndr_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_supplementalCredentialsSubBlob(&r->sub, ndr->flags):r->__ndr_size);
	ndr_print_uint32(ndr, "unknown2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->unknown2);
	ndr_print_supplementalCredentialsSubBlob(ndr, "sub", &r->sub);
	ndr_print_uint8(ndr, "unknown3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->unknown3);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_package_PackagesBlob(struct ndr_push *ndr, int ndr_flags, const struct package_PackagesBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		{
			uint32_t _flags_save_string_array = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_string_array(ndr, NDR_SCALARS, r->names));
			ndr->flags = _flags_save_string_array;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_package_PackagesBlob(struct ndr_pull *ndr, int ndr_flags, struct package_PackagesBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		{
			uint32_t _flags_save_string_array = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_string_array(ndr, NDR_SCALARS, &r->names));
			ndr->flags = _flags_save_string_array;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PackagesBlob(struct ndr_print *ndr, const char *name, const struct package_PackagesBlob *r)
{
	ndr_print_struct(ndr, name, "package_PackagesBlob");
	ndr->depth++;
	ndr_print_string_array(ndr, "names", r->names);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosString(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosString *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 2 * strlen_m(r->string)));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 2 * strlen_m(r->string)));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->string));
			ndr->flags = _flags_save_string;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			if (r->string) {
				NDR_CHECK(ndr_push_relative_ptr2(ndr, r->string));
				{
					struct ndr_push *_ndr_string;
					NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_string, 0, 2 * strlen_m(r->string)));
					NDR_CHECK(ndr_push_string(_ndr_string, NDR_SCALARS, r->string));
					NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_string, 0, 2 * strlen_m(r->string)));
				}
			}
			ndr->flags = _flags_save_string;
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosString(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosString *r)
{
	uint32_t _ptr_string;
	TALLOC_CTX *_mem_save_string_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->length));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->size));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_string));
			if (_ptr_string) {
				NDR_PULL_ALLOC(ndr, r->string);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->string, _ptr_string));
			} else {
				r->string = NULL;
			}
			ndr->flags = _flags_save_string;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			if (r->string) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->string));
				_mem_save_string_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->string, 0);
				{
					struct ndr_pull *_ndr_string;
					NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_string, 0, r->size));
					NDR_CHECK(ndr_pull_string(_ndr_string, NDR_SCALARS, &r->string));
					NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_string, 0, r->size));
				}
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_string_0, 0);
				ndr->offset = _relative_save_offset;
			}
			ndr->flags = _flags_save_string;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosString(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosString *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryKerberosString");
	ndr->depth++;
	ndr_print_uint16(ndr, "length", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?2 * strlen_m(r->string):r->length);
	ndr_print_uint16(ndr, "size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?2 * strlen_m(r->string):r->size);
	ndr_print_ptr(ndr, "string", r->string);
	ndr->depth++;
	if (r->string) {
		ndr_print_string(ndr, "string", r->string);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosKey3(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosKey3 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->keytype));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, (r->value?r->value->length:0)));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->value));
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			if (r->value) {
				NDR_CHECK(ndr_push_relative_ptr2(ndr, r->value));
				{
					struct ndr_push *_ndr_value;
					NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_value, 0, (r->value?r->value->length:0)));
					NDR_CHECK(ndr_push_DATA_BLOB(_ndr_value, NDR_SCALARS, *r->value));
					NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_value, 0, (r->value?r->value->length:0)));
				}
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosKey3(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosKey3 *r)
{
	uint32_t _ptr_value;
	TALLOC_CTX *_mem_save_value_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved1));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->keytype));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->value_len));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_value));
			if (_ptr_value) {
				NDR_PULL_ALLOC(ndr, r->value);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->value, _ptr_value));
			} else {
				r->value = NULL;
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			if (r->value) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->value));
				_mem_save_value_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->value, 0);
				{
					struct ndr_pull *_ndr_value;
					NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_value, 0, r->value_len));
					NDR_CHECK(ndr_pull_DATA_BLOB(_ndr_value, NDR_SCALARS, r->value));
					NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_value, 0, r->value_len));
				}
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_value_0, 0);
				ndr->offset = _relative_save_offset;
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosKey3(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosKey3 *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryKerberosKey3");
	ndr->depth++;
	ndr_print_uint16(ndr, "reserved1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved1);
	ndr_print_uint16(ndr, "reserved2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved2);
	ndr_print_uint32(ndr, "reserved3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved3);
	ndr_print_uint32(ndr, "keytype", r->keytype);
	ndr_print_uint32(ndr, "value_len", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?(r->value?r->value->length:0):r->value_len);
	ndr_print_ptr(ndr, "value", r->value);
	ndr->depth++;
	if (r->value) {
		ndr_print_DATA_BLOB(ndr, "value", *r->value);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosCtr3(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosCtr3 *r)
{
	uint32_t cntr_keys_0;
	uint32_t cntr_old_keys_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_keys));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_old_keys));
		NDR_CHECK(ndr_push_package_PrimaryKerberosString(ndr, NDR_SCALARS, &r->salt));
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey3(ndr, NDR_SCALARS, &r->keys[cntr_keys_0]));
		}
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey3(ndr, NDR_SCALARS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_package_PrimaryKerberosString(ndr, NDR_BUFFERS, &r->salt));
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey3(ndr, NDR_BUFFERS, &r->keys[cntr_keys_0]));
		}
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey3(ndr, NDR_BUFFERS, &r->old_keys[cntr_old_keys_0]));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosCtr3(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosCtr3 *r)
{
	uint32_t cntr_keys_0;
	TALLOC_CTX *_mem_save_keys_0;
	uint32_t cntr_old_keys_0;
	TALLOC_CTX *_mem_save_old_keys_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_keys));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_old_keys));
		NDR_CHECK(ndr_pull_package_PrimaryKerberosString(ndr, NDR_SCALARS, &r->salt));
		NDR_PULL_ALLOC_N(ndr, r->keys, r->num_keys);
		_mem_save_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->keys, 0);
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey3(ndr, NDR_SCALARS, &r->keys[cntr_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_keys_0, 0);
		NDR_PULL_ALLOC_N(ndr, r->old_keys, r->num_old_keys);
		_mem_save_old_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->old_keys, 0);
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey3(ndr, NDR_SCALARS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_old_keys_0, 0);
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding1));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_package_PrimaryKerberosString(ndr, NDR_BUFFERS, &r->salt));
		_mem_save_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->keys, 0);
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey3(ndr, NDR_BUFFERS, &r->keys[cntr_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_keys_0, 0);
		_mem_save_old_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->old_keys, 0);
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey3(ndr, NDR_BUFFERS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_old_keys_0, 0);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosCtr3(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosCtr3 *r)
{
	uint32_t cntr_keys_0;
	uint32_t cntr_old_keys_0;
	ndr_print_struct(ndr, name, "package_PrimaryKerberosCtr3");
	ndr->depth++;
	ndr_print_uint16(ndr, "num_keys", r->num_keys);
	ndr_print_uint16(ndr, "num_old_keys", r->num_old_keys);
	ndr_print_package_PrimaryKerberosString(ndr, "salt", &r->salt);
	ndr->print(ndr, "%s: ARRAY(%d)", "keys", (int)r->num_keys);
	ndr->depth++;
	for (cntr_keys_0=0;cntr_keys_0<r->num_keys;cntr_keys_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_keys_0) != -1) {
			ndr_print_package_PrimaryKerberosKey3(ndr, "keys", &r->keys[cntr_keys_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->print(ndr, "%s: ARRAY(%d)", "old_keys", (int)r->num_old_keys);
	ndr->depth++;
	for (cntr_old_keys_0=0;cntr_old_keys_0<r->num_old_keys;cntr_old_keys_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_old_keys_0) != -1) {
			ndr_print_package_PrimaryKerberosKey3(ndr, "old_keys", &r->old_keys[cntr_old_keys_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr_print_uint32(ndr, "padding1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding1);
	ndr_print_uint32(ndr, "padding2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding2);
	ndr_print_uint32(ndr, "padding3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding3);
	ndr_print_uint32(ndr, "padding4", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding4);
	ndr_print_uint32(ndr, "padding5", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding5);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosKey4(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosKey4 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->iteration_count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->keytype));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, (r->value?r->value->length:0)));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->value));
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			if (r->value) {
				NDR_CHECK(ndr_push_relative_ptr2(ndr, r->value));
				{
					struct ndr_push *_ndr_value;
					NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_value, 0, (r->value?r->value->length:0)));
					NDR_CHECK(ndr_push_DATA_BLOB(_ndr_value, NDR_SCALARS, *r->value));
					NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_value, 0, (r->value?r->value->length:0)));
				}
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosKey4(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosKey4 *r)
{
	uint32_t _ptr_value;
	TALLOC_CTX *_mem_save_value_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved1));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->iteration_count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->keytype));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->value_len));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_value));
			if (_ptr_value) {
				NDR_PULL_ALLOC(ndr, r->value);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->value, _ptr_value));
			} else {
				r->value = NULL;
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			if (r->value) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->value));
				_mem_save_value_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->value, 0);
				{
					struct ndr_pull *_ndr_value;
					NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_value, 0, r->value_len));
					NDR_CHECK(ndr_pull_DATA_BLOB(_ndr_value, NDR_SCALARS, r->value));
					NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_value, 0, r->value_len));
				}
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_value_0, 0);
				ndr->offset = _relative_save_offset;
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosKey4(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosKey4 *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryKerberosKey4");
	ndr->depth++;
	ndr_print_uint16(ndr, "reserved1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved1);
	ndr_print_uint16(ndr, "reserved2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved2);
	ndr_print_uint32(ndr, "reserved3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved3);
	ndr_print_uint32(ndr, "iteration_count", r->iteration_count);
	ndr_print_uint32(ndr, "keytype", r->keytype);
	ndr_print_uint32(ndr, "value_len", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?(r->value?r->value->length:0):r->value_len);
	ndr_print_ptr(ndr, "value", r->value);
	ndr->depth++;
	if (r->value) {
		ndr_print_DATA_BLOB(ndr, "value", *r->value);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosCtr4(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosCtr4 *r)
{
	uint32_t cntr_keys_0;
	uint32_t cntr_service_keys_0;
	uint32_t cntr_old_keys_0;
	uint32_t cntr_older_keys_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_keys));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_old_keys));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_older_keys));
		NDR_CHECK(ndr_push_package_PrimaryKerberosString(ndr, NDR_SCALARS, &r->salt));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->default_iteration_count));
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->keys[cntr_keys_0]));
		}
		for (cntr_service_keys_0 = 0; cntr_service_keys_0 < 0; cntr_service_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->service_keys[cntr_service_keys_0]));
		}
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->old_keys[cntr_old_keys_0]));
		}
		for (cntr_older_keys_0 = 0; cntr_older_keys_0 < r->num_older_keys; cntr_older_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->older_keys[cntr_older_keys_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_package_PrimaryKerberosString(ndr, NDR_BUFFERS, &r->salt));
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->keys[cntr_keys_0]));
		}
		for (cntr_service_keys_0 = 0; cntr_service_keys_0 < 0; cntr_service_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->service_keys[cntr_service_keys_0]));
		}
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->old_keys[cntr_old_keys_0]));
		}
		for (cntr_older_keys_0 = 0; cntr_older_keys_0 < r->num_older_keys; cntr_older_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->older_keys[cntr_older_keys_0]));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosCtr4(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosCtr4 *r)
{
	uint32_t cntr_keys_0;
	TALLOC_CTX *_mem_save_keys_0;
	uint32_t cntr_service_keys_0;
	TALLOC_CTX *_mem_save_service_keys_0;
	uint32_t cntr_old_keys_0;
	TALLOC_CTX *_mem_save_old_keys_0;
	uint32_t cntr_older_keys_0;
	TALLOC_CTX *_mem_save_older_keys_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_keys));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_service_keys));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_old_keys));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_older_keys));
		NDR_CHECK(ndr_pull_package_PrimaryKerberosString(ndr, NDR_SCALARS, &r->salt));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->default_iteration_count));
		NDR_PULL_ALLOC_N(ndr, r->keys, r->num_keys);
		_mem_save_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->keys, 0);
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->keys[cntr_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_keys_0, 0);
		NDR_PULL_ALLOC_N(ndr, r->service_keys, r->num_service_keys);
		_mem_save_service_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->service_keys, 0);
		for (cntr_service_keys_0 = 0; cntr_service_keys_0 < r->num_service_keys; cntr_service_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->service_keys[cntr_service_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_service_keys_0, 0);
		NDR_PULL_ALLOC_N(ndr, r->old_keys, r->num_old_keys);
		_mem_save_old_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->old_keys, 0);
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_old_keys_0, 0);
		NDR_PULL_ALLOC_N(ndr, r->older_keys, r->num_older_keys);
		_mem_save_older_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->older_keys, 0);
		for (cntr_older_keys_0 = 0; cntr_older_keys_0 < r->num_older_keys; cntr_older_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->older_keys[cntr_older_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_older_keys_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_package_PrimaryKerberosString(ndr, NDR_BUFFERS, &r->salt));
		_mem_save_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->keys, 0);
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->keys[cntr_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_keys_0, 0);
		_mem_save_service_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->service_keys, 0);
		for (cntr_service_keys_0 = 0; cntr_service_keys_0 < r->num_service_keys; cntr_service_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->service_keys[cntr_service_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_service_keys_0, 0);
		_mem_save_old_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->old_keys, 0);
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_old_keys_0, 0);
		_mem_save_older_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->older_keys, 0);
		for (cntr_older_keys_0 = 0; cntr_older_keys_0 < r->num_older_keys; cntr_older_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->older_keys[cntr_older_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_older_keys_0, 0);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosCtr4(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosCtr4 *r)
{
	uint32_t cntr_keys_0;
	uint32_t cntr_service_keys_0;
	uint32_t cntr_old_keys_0;
	uint32_t cntr_older_keys_0;
	ndr_print_struct(ndr, name, "package_PrimaryKerberosCtr4");
	ndr->depth++;
	ndr_print_uint16(ndr, "num_keys", r->num_keys);
	ndr_print_uint16(ndr, "num_service_keys", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->num_service_keys);
	ndr_print_uint16(ndr, "num_old_keys", r->num_old_keys);
	ndr_print_uint16(ndr, "num_older_keys", r->num_older_keys);
	ndr_print_package_PrimaryKerberosString(ndr, "salt", &r->salt);
	ndr_print_uint32(ndr, "default_iteration_count", r->default_iteration_count);
	ndr->print(ndr, "%s: ARRAY(%d)", "keys", (int)r->num_keys);
	ndr->depth++;
	for (cntr_keys_0=0;cntr_keys_0<r->num_keys;cntr_keys_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_keys_0) != -1) {
			ndr_print_package_PrimaryKerberosKey4(ndr, "keys", &r->keys[cntr_keys_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->print(ndr, "%s: ARRAY(%d)", "service_keys", (int)r->num_service_keys);
	ndr->depth++;
	for (cntr_service_keys_0=0;cntr_service_keys_0<r->num_service_keys;cntr_service_keys_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_service_keys_0) != -1) {
			ndr_print_package_PrimaryKerberosKey4(ndr, "service_keys", &r->service_keys[cntr_service_keys_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->print(ndr, "%s: ARRAY(%d)", "old_keys", (int)r->num_old_keys);
	ndr->depth++;
	for (cntr_old_keys_0=0;cntr_old_keys_0<r->num_old_keys;cntr_old_keys_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_old_keys_0) != -1) {
			ndr_print_package_PrimaryKerberosKey4(ndr, "old_keys", &r->old_keys[cntr_old_keys_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->print(ndr, "%s: ARRAY(%d)", "older_keys", (int)r->num_older_keys);
	ndr->depth++;
	for (cntr_older_keys_0=0;cntr_older_keys_0<r->num_older_keys;cntr_older_keys_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_older_keys_0) != -1) {
			ndr_print_package_PrimaryKerberosKey4(ndr, "older_keys", &r->older_keys[cntr_older_keys_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosCtr(struct ndr_push *ndr, int ndr_flags, const union package_PrimaryKerberosCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 3: {
				NDR_CHECK(ndr_push_package_PrimaryKerberosCtr3(ndr, NDR_SCALARS, &r->ctr3));
			break; }

			case 4: {
				NDR_CHECK(ndr_push_package_PrimaryKerberosCtr4(ndr, NDR_SCALARS, &r->ctr4));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 3:
				NDR_CHECK(ndr_push_package_PrimaryKerberosCtr3(ndr, NDR_BUFFERS, &r->ctr3));
			break;

			case 4:
				NDR_CHECK(ndr_push_package_PrimaryKerberosCtr4(ndr, NDR_BUFFERS, &r->ctr4));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosCtr(struct ndr_pull *ndr, int ndr_flags, union package_PrimaryKerberosCtr *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 3: {
				NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr3(ndr, NDR_SCALARS, &r->ctr3));
			break; }

			case 4: {
				NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr4(ndr, NDR_SCALARS, &r->ctr4));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 3:
				NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr3(ndr, NDR_BUFFERS, &r->ctr3));
			break;

			case 4:
				NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr4(ndr, NDR_BUFFERS, &r->ctr4));
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosCtr(struct ndr_print *ndr, const char *name, const union package_PrimaryKerberosCtr *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "package_PrimaryKerberosCtr");
	switch (level) {
		case 3:
			ndr_print_package_PrimaryKerberosCtr3(ndr, "ctr3", &r->ctr3);
		break;

		case 4:
			ndr_print_package_PrimaryKerberosCtr4(ndr, "ctr4", &r->ctr4);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_package_PrimaryKerberosBlob(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_package_PrimaryKerberosCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_package_PrimaryKerberosCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_package_PrimaryKerberosBlob(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->flags));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosBlob(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosBlob *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryKerberosBlob");
	ndr->depth++;
	ndr_print_uint16(ndr, "version", r->version);
	ndr_print_uint16(ndr, "flags", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->flags);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_package_PrimaryKerberosCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_package_PrimaryCLEARTEXTBlob(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryCLEARTEXTBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_string(ndr, NDR_SCALARS, r->cleartext));
			ndr->flags = _flags_save_string;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_package_PrimaryCLEARTEXTBlob(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryCLEARTEXTBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_string(ndr, NDR_SCALARS, &r->cleartext));
			ndr->flags = _flags_save_string;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryCLEARTEXTBlob(struct ndr_print *ndr, const char *name, const struct package_PrimaryCLEARTEXTBlob *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryCLEARTEXTBlob");
	ndr->depth++;
	ndr_print_string(ndr, "cleartext", r->cleartext);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryWDigestHash(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryWDigestHash *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 1));
			NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->hash, 16));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryWDigestHash(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryWDigestHash *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 1));
			NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->hash, 16));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryWDigestHash(struct ndr_print *ndr, const char *name, const struct package_PrimaryWDigestHash *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryWDigestHash");
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		ndr->depth++;
		ndr_print_array_uint8(ndr, "hash", r->hash, 16);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_package_PrimaryWDigestBlob(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryWDigestBlob *r)
{
	uint32_t cntr_hashes_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0x31));
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, 0x01));
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->num_hashes));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_udlong(ndr, NDR_SCALARS, 0));
		for (cntr_hashes_0 = 0; cntr_hashes_0 < r->num_hashes; cntr_hashes_0++) {
			NDR_CHECK(ndr_push_package_PrimaryWDigestHash(ndr, NDR_SCALARS, &r->hashes[cntr_hashes_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_package_PrimaryWDigestBlob(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryWDigestBlob *r)
{
	uint32_t cntr_hashes_0;
	TALLOC_CTX *_mem_save_hashes_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->unknown1));
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->unknown2));
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->num_hashes));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown3));
		NDR_CHECK(ndr_pull_udlong(ndr, NDR_SCALARS, &r->uuknown4));
		NDR_PULL_ALLOC_N(ndr, r->hashes, r->num_hashes);
		_mem_save_hashes_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->hashes, 0);
		for (cntr_hashes_0 = 0; cntr_hashes_0 < r->num_hashes; cntr_hashes_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryWDigestHash(ndr, NDR_SCALARS, &r->hashes[cntr_hashes_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_hashes_0, 0);
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryWDigestBlob(struct ndr_print *ndr, const char *name, const struct package_PrimaryWDigestBlob *r)
{
	uint32_t cntr_hashes_0;
	ndr_print_struct(ndr, name, "package_PrimaryWDigestBlob");
	ndr->depth++;
	ndr_print_uint16(ndr, "unknown1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0x31:r->unknown1);
	ndr_print_uint8(ndr, "unknown2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0x01:r->unknown2);
	ndr_print_uint8(ndr, "num_hashes", r->num_hashes);
	ndr_print_uint32(ndr, "unknown3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->unknown3);
	ndr_print_udlong(ndr, "uuknown4", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->uuknown4);
	ndr->print(ndr, "%s: ARRAY(%d)", "hashes", (int)r->num_hashes);
	ndr->depth++;
	for (cntr_hashes_0=0;cntr_hashes_0<r->num_hashes;cntr_hashes_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_hashes_0) != -1) {
			ndr_print_package_PrimaryWDigestHash(ndr, "hashes", &r->hashes[cntr_hashes_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_trustAuthInOutSecret1(struct ndr_push *ndr, int ndr_flags, const struct trustAuthInOutSecret1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->time1));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->unknown1));
		NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->value));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
			NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->_pad));
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_trustAuthInOutSecret1(struct ndr_pull *ndr, int ndr_flags, struct trustAuthInOutSecret1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->time1));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown1));
		NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->value));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
			NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->_pad));
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_trustAuthInOutSecret1(struct ndr_print *ndr, const char *name, const struct trustAuthInOutSecret1 *r)
{
	ndr_print_struct(ndr, name, "trustAuthInOutSecret1");
	ndr->depth++;
	ndr_print_NTTIME(ndr, "time1", r->time1);
	ndr_print_uint32(ndr, "unknown1", r->unknown1);
	ndr_print_DATA_BLOB(ndr, "value", r->value);
	ndr_print_DATA_BLOB(ndr, "_pad", r->_pad);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_trustAuthInOutCtr1(struct ndr_push *ndr, int ndr_flags, const struct trustAuthInOutCtr1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_relative_ptr1(ndr, r->value1));
		NDR_CHECK(ndr_push_relative_ptr1(ndr, r->value2));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->value1) {
			NDR_CHECK(ndr_push_relative_ptr2(ndr, r->value1));
			NDR_CHECK(ndr_push_trustAuthInOutSecret1(ndr, NDR_SCALARS, r->value1));
		}
		if (r->value2) {
			NDR_CHECK(ndr_push_relative_ptr2(ndr, r->value2));
			NDR_CHECK(ndr_push_trustAuthInOutSecret1(ndr, NDR_SCALARS, r->value2));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_trustAuthInOutCtr1(struct ndr_pull *ndr, int ndr_flags, struct trustAuthInOutCtr1 *r)
{
	uint32_t _ptr_value1;
	TALLOC_CTX *_mem_save_value1_0;
	uint32_t _ptr_value2;
	TALLOC_CTX *_mem_save_value2_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_value1));
		if (_ptr_value1) {
			NDR_PULL_ALLOC(ndr, r->value1);
			NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->value1, _ptr_value1));
		} else {
			r->value1 = NULL;
		}
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_value2));
		if (_ptr_value2) {
			NDR_PULL_ALLOC(ndr, r->value2);
			NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->value2, _ptr_value2));
		} else {
			r->value2 = NULL;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->value1) {
			uint32_t _relative_save_offset;
			_relative_save_offset = ndr->offset;
			NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->value1));
			_mem_save_value1_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->value1, 0);
			NDR_CHECK(ndr_pull_trustAuthInOutSecret1(ndr, NDR_SCALARS, r->value1));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_value1_0, 0);
			ndr->offset = _relative_save_offset;
		}
		if (r->value2) {
			uint32_t _relative_save_offset;
			_relative_save_offset = ndr->offset;
			NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->value2));
			_mem_save_value2_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->value2, 0);
			NDR_CHECK(ndr_pull_trustAuthInOutSecret1(ndr, NDR_SCALARS, r->value2));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_value2_0, 0);
			ndr->offset = _relative_save_offset;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_trustAuthInOutCtr1(struct ndr_print *ndr, const char *name, const struct trustAuthInOutCtr1 *r)
{
	ndr_print_struct(ndr, name, "trustAuthInOutCtr1");
	ndr->depth++;
	ndr_print_ptr(ndr, "value1", r->value1);
	ndr->depth++;
	if (r->value1) {
		ndr_print_trustAuthInOutSecret1(ndr, "value1", r->value1);
	}
	ndr->depth--;
	ndr_print_ptr(ndr, "value2", r->value2);
	ndr->depth++;
	if (r->value2) {
		ndr_print_trustAuthInOutSecret1(ndr, "value2", r->value2);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_trustAuthInOutSecret2V1(struct ndr_push *ndr, int ndr_flags, const struct trustAuthInOutSecret2V1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->time1));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->unknown1));
		NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->value));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->time2));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->unknown2));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->unknown3));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->unknown4));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
			NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->_pad));
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_trustAuthInOutSecret2V1(struct ndr_pull *ndr, int ndr_flags, struct trustAuthInOutSecret2V1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->time1));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown1));
		NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->value));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->time2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown4));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
			NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->_pad));
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_trustAuthInOutSecret2V1(struct ndr_print *ndr, const char *name, const struct trustAuthInOutSecret2V1 *r)
{
	ndr_print_struct(ndr, name, "trustAuthInOutSecret2V1");
	ndr->depth++;
	ndr_print_NTTIME(ndr, "time1", r->time1);
	ndr_print_uint32(ndr, "unknown1", r->unknown1);
	ndr_print_DATA_BLOB(ndr, "value", r->value);
	ndr_print_NTTIME(ndr, "time2", r->time2);
	ndr_print_uint32(ndr, "unknown2", r->unknown2);
	ndr_print_uint32(ndr, "unknown3", r->unknown3);
	ndr_print_uint32(ndr, "unknown4", r->unknown4);
	ndr_print_DATA_BLOB(ndr, "_pad", r->_pad);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_trustAuthInOutSecret2V2(struct ndr_push *ndr, int ndr_flags, const struct trustAuthInOutSecret2V2 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->time1));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->unknown1));
		NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->value));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->time2));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->unknown2));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->unknown3));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
			NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->_pad));
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_trustAuthInOutSecret2V2(struct ndr_pull *ndr, int ndr_flags, struct trustAuthInOutSecret2V2 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->time1));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown1));
		NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->value));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->time2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown3));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
			NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->_pad));
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_trustAuthInOutSecret2V2(struct ndr_print *ndr, const char *name, const struct trustAuthInOutSecret2V2 *r)
{
	ndr_print_struct(ndr, name, "trustAuthInOutSecret2V2");
	ndr->depth++;
	ndr_print_NTTIME(ndr, "time1", r->time1);
	ndr_print_uint32(ndr, "unknown1", r->unknown1);
	ndr_print_DATA_BLOB(ndr, "value", r->value);
	ndr_print_NTTIME(ndr, "time2", r->time2);
	ndr_print_uint32(ndr, "unknown2", r->unknown2);
	ndr_print_uint32(ndr, "unknown3", r->unknown3);
	ndr_print_DATA_BLOB(ndr, "_pad", r->_pad);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_trustAuthInOutCtr2(struct ndr_push *ndr, int ndr_flags, const struct trustAuthInOutCtr2 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_relative_ptr1(ndr, r->value1));
		NDR_CHECK(ndr_push_relative_ptr1(ndr, r->value2));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->value1) {
			NDR_CHECK(ndr_push_relative_ptr2(ndr, r->value1));
			NDR_CHECK(ndr_push_trustAuthInOutSecret2V1(ndr, NDR_SCALARS, r->value1));
		}
		if (r->value2) {
			NDR_CHECK(ndr_push_relative_ptr2(ndr, r->value2));
			NDR_CHECK(ndr_push_trustAuthInOutSecret2V2(ndr, NDR_SCALARS, r->value2));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_trustAuthInOutCtr2(struct ndr_pull *ndr, int ndr_flags, struct trustAuthInOutCtr2 *r)
{
	uint32_t _ptr_value1;
	TALLOC_CTX *_mem_save_value1_0;
	uint32_t _ptr_value2;
	TALLOC_CTX *_mem_save_value2_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_value1));
		if (_ptr_value1) {
			NDR_PULL_ALLOC(ndr, r->value1);
			NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->value1, _ptr_value1));
		} else {
			r->value1 = NULL;
		}
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_value2));
		if (_ptr_value2) {
			NDR_PULL_ALLOC(ndr, r->value2);
			NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->value2, _ptr_value2));
		} else {
			r->value2 = NULL;
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->value1) {
			uint32_t _relative_save_offset;
			_relative_save_offset = ndr->offset;
			NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->value1));
			_mem_save_value1_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->value1, 0);
			NDR_CHECK(ndr_pull_trustAuthInOutSecret2V1(ndr, NDR_SCALARS, r->value1));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_value1_0, 0);
			ndr->offset = _relative_save_offset;
		}
		if (r->value2) {
			uint32_t _relative_save_offset;
			_relative_save_offset = ndr->offset;
			NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->value2));
			_mem_save_value2_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->value2, 0);
			NDR_CHECK(ndr_pull_trustAuthInOutSecret2V2(ndr, NDR_SCALARS, r->value2));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_value2_0, 0);
			ndr->offset = _relative_save_offset;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_trustAuthInOutCtr2(struct ndr_print *ndr, const char *name, const struct trustAuthInOutCtr2 *r)
{
	ndr_print_struct(ndr, name, "trustAuthInOutCtr2");
	ndr->depth++;
	ndr_print_ptr(ndr, "value1", r->value1);
	ndr->depth++;
	if (r->value1) {
		ndr_print_trustAuthInOutSecret2V1(ndr, "value1", r->value1);
	}
	ndr->depth--;
	ndr_print_ptr(ndr, "value2", r->value2);
	ndr->depth++;
	if (r->value2) {
		ndr_print_trustAuthInOutSecret2V2(ndr, "value2", r->value2);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_trustAuthInOutCtr(struct ndr_push *ndr, int ndr_flags, const union trustAuthInOutCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_trustAuthInOutCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_push_trustAuthInOutCtr2(ndr, NDR_SCALARS, &r->ctr2));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		int level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
				NDR_CHECK(ndr_push_trustAuthInOutCtr1(ndr, NDR_BUFFERS, &r->ctr1));
			break;

			case 2:
				NDR_CHECK(ndr_push_trustAuthInOutCtr2(ndr, NDR_BUFFERS, &r->ctr2));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_trustAuthInOutCtr(struct ndr_pull *ndr, int ndr_flags, union trustAuthInOutCtr *r)
{
	int level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_trustAuthInOutCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_pull_trustAuthInOutCtr2(ndr, NDR_SCALARS, &r->ctr2));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
				NDR_CHECK(ndr_pull_trustAuthInOutCtr1(ndr, NDR_BUFFERS, &r->ctr1));
			break;

			case 2:
				NDR_CHECK(ndr_pull_trustAuthInOutCtr2(ndr, NDR_BUFFERS, &r->ctr2));
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_trustAuthInOutCtr(struct ndr_print *ndr, const char *name, const union trustAuthInOutCtr *r)
{
	int level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "trustAuthInOutCtr");
	switch (level) {
		case 1:
			ndr_print_trustAuthInOutCtr1(ndr, "ctr1", &r->ctr1);
		break;

		case 2:
			ndr_print_trustAuthInOutCtr2(ndr, "ctr2", &r->ctr2);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_trustAuthInOutBlob(struct ndr_push *ndr, int ndr_flags, const struct trustAuthInOutBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_trustAuthInOutCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_trustAuthInOutCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_trustAuthInOutBlob(struct ndr_pull *ndr, int ndr_flags, struct trustAuthInOutBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_trustAuthInOutCtr(ndr, NDR_SCALARS, &r->ctr));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_trustAuthInOutCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_trustAuthInOutBlob(struct ndr_print *ndr, const char *name, const struct trustAuthInOutBlob *r)
{
	ndr_print_struct(ndr, name, "trustAuthInOutBlob");
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_trustAuthInOutCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_DsCompressedChunk(struct ndr_push *ndr, int ndr_flags, const struct DsCompressedChunk *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->marker));
		NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->data));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_DsCompressedChunk(struct ndr_pull *ndr, int ndr_flags, struct DsCompressedChunk *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->marker));
		NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->data));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_DsCompressedChunk(struct ndr_print *ndr, const char *name, const struct DsCompressedChunk *r)
{
	ndr_print_struct(ndr, name, "DsCompressedChunk");
	ndr->depth++;
	ndr_print_uint32(ndr, "marker", r->marker);
	ndr_print_DATA_BLOB(ndr, "data", r->data);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_DsCompressedBlob(struct ndr_push *ndr, int ndr_flags, const struct DsCompressedBlob *r)
{
	uint32_t cntr_chunks_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		for (cntr_chunks_0 = 0; cntr_chunks_0 < 5; cntr_chunks_0++) {
			NDR_CHECK(ndr_push_DsCompressedChunk(ndr, NDR_SCALARS, &r->chunks[cntr_chunks_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_DsCompressedBlob(struct ndr_pull *ndr, int ndr_flags, struct DsCompressedBlob *r)
{
	uint32_t cntr_chunks_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		for (cntr_chunks_0 = 0; cntr_chunks_0 < 5; cntr_chunks_0++) {
			NDR_CHECK(ndr_pull_DsCompressedChunk(ndr, NDR_SCALARS, &r->chunks[cntr_chunks_0]));
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_DsCompressedBlob(struct ndr_print *ndr, const char *name, const struct DsCompressedBlob *r)
{
	uint32_t cntr_chunks_0;
	ndr_print_struct(ndr, name, "DsCompressedBlob");
	ndr->depth++;
	ndr->print(ndr, "%s: ARRAY(%d)", "chunks", (int)5);
	ndr->depth++;
	for (cntr_chunks_0=0;cntr_chunks_0<5;cntr_chunks_0++) {
		char *idx_0=NULL;
		if (asprintf(&idx_0, "[%d]", cntr_chunks_0) != -1) {
			ndr_print_DsCompressedChunk(ndr, "chunks", &r->chunks[cntr_chunks_0]);
			free(idx_0);
		}
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_replPropertyMetaData(struct ndr_push *ndr, int flags, const struct decode_replPropertyMetaData *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_replPropertyMetaDataBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_replPropertyMetaData(struct ndr_pull *ndr, int flags, struct decode_replPropertyMetaData *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_replPropertyMetaDataBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_replPropertyMetaData(struct ndr_print *ndr, const char *name, int flags, const struct decode_replPropertyMetaData *r)
{
	ndr_print_struct(ndr, name, "decode_replPropertyMetaData");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_replPropertyMetaData");
		ndr->depth++;
		ndr_print_replPropertyMetaDataBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_replPropertyMetaData");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_replUpToDateVector(struct ndr_push *ndr, int flags, const struct decode_replUpToDateVector *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_replUpToDateVectorBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_replUpToDateVector(struct ndr_pull *ndr, int flags, struct decode_replUpToDateVector *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_replUpToDateVectorBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_replUpToDateVector(struct ndr_print *ndr, const char *name, int flags, const struct decode_replUpToDateVector *r)
{
	ndr_print_struct(ndr, name, "decode_replUpToDateVector");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_replUpToDateVector");
		ndr->depth++;
		ndr_print_replUpToDateVectorBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_replUpToDateVector");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_repsFromTo(struct ndr_push *ndr, int flags, const struct decode_repsFromTo *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_repsFromToBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_repsFromTo(struct ndr_pull *ndr, int flags, struct decode_repsFromTo *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_repsFromToBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_repsFromTo(struct ndr_print *ndr, const char *name, int flags, const struct decode_repsFromTo *r)
{
	ndr_print_struct(ndr, name, "decode_repsFromTo");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_repsFromTo");
		ndr->depth++;
		ndr_print_repsFromToBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_repsFromTo");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_partialAttributeSet(struct ndr_push *ndr, int flags, const struct decode_partialAttributeSet *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_partialAttributeSetBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_partialAttributeSet(struct ndr_pull *ndr, int flags, struct decode_partialAttributeSet *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_partialAttributeSetBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_partialAttributeSet(struct ndr_print *ndr, const char *name, int flags, const struct decode_partialAttributeSet *r)
{
	ndr_print_struct(ndr, name, "decode_partialAttributeSet");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_partialAttributeSet");
		ndr->depth++;
		ndr_print_partialAttributeSetBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_partialAttributeSet");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_prefixMap(struct ndr_push *ndr, int flags, const struct decode_prefixMap *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_prefixMapBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_prefixMap(struct ndr_pull *ndr, int flags, struct decode_prefixMap *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_prefixMapBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_prefixMap(struct ndr_print *ndr, const char *name, int flags, const struct decode_prefixMap *r)
{
	ndr_print_struct(ndr, name, "decode_prefixMap");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_prefixMap");
		ndr->depth++;
		ndr_print_prefixMapBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_prefixMap");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_ldapControlDirSync(struct ndr_push *ndr, int flags, const struct decode_ldapControlDirSync *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_ldapControlDirSyncCookie(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.cookie));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_ldapControlDirSync(struct ndr_pull *ndr, int flags, struct decode_ldapControlDirSync *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_ldapControlDirSyncCookie(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.cookie));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_ldapControlDirSync(struct ndr_print *ndr, const char *name, int flags, const struct decode_ldapControlDirSync *r)
{
	ndr_print_struct(ndr, name, "decode_ldapControlDirSync");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_ldapControlDirSync");
		ndr->depth++;
		ndr_print_ldapControlDirSyncCookie(ndr, "cookie", &r->in.cookie);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_ldapControlDirSync");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_supplementalCredentials(struct ndr_push *ndr, int flags, const struct decode_supplementalCredentials *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_supplementalCredentialsBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_supplementalCredentials(struct ndr_pull *ndr, int flags, struct decode_supplementalCredentials *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_supplementalCredentialsBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_supplementalCredentials(struct ndr_print *ndr, const char *name, int flags, const struct decode_supplementalCredentials *r)
{
	ndr_print_struct(ndr, name, "decode_supplementalCredentials");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_supplementalCredentials");
		ndr->depth++;
		ndr_print_supplementalCredentialsBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_supplementalCredentials");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_Packages(struct ndr_push *ndr, int flags, const struct decode_Packages *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_package_PackagesBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_Packages(struct ndr_pull *ndr, int flags, struct decode_Packages *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_package_PackagesBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_Packages(struct ndr_print *ndr, const char *name, int flags, const struct decode_Packages *r)
{
	ndr_print_struct(ndr, name, "decode_Packages");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_Packages");
		ndr->depth++;
		ndr_print_package_PackagesBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_Packages");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_PrimaryKerberos(struct ndr_push *ndr, int flags, const struct decode_PrimaryKerberos *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_package_PrimaryKerberosBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_PrimaryKerberos(struct ndr_pull *ndr, int flags, struct decode_PrimaryKerberos *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_package_PrimaryKerberosBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_PrimaryKerberos(struct ndr_print *ndr, const char *name, int flags, const struct decode_PrimaryKerberos *r)
{
	ndr_print_struct(ndr, name, "decode_PrimaryKerberos");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_PrimaryKerberos");
		ndr->depth++;
		ndr_print_package_PrimaryKerberosBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_PrimaryKerberos");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_PrimaryCLEARTEXT(struct ndr_push *ndr, int flags, const struct decode_PrimaryCLEARTEXT *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_package_PrimaryCLEARTEXTBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_PrimaryCLEARTEXT(struct ndr_pull *ndr, int flags, struct decode_PrimaryCLEARTEXT *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_package_PrimaryCLEARTEXTBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_PrimaryCLEARTEXT(struct ndr_print *ndr, const char *name, int flags, const struct decode_PrimaryCLEARTEXT *r)
{
	ndr_print_struct(ndr, name, "decode_PrimaryCLEARTEXT");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_PrimaryCLEARTEXT");
		ndr->depth++;
		ndr_print_package_PrimaryCLEARTEXTBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_PrimaryCLEARTEXT");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_PrimaryWDigest(struct ndr_push *ndr, int flags, const struct decode_PrimaryWDigest *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_package_PrimaryWDigestBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_PrimaryWDigest(struct ndr_pull *ndr, int flags, struct decode_PrimaryWDigest *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_package_PrimaryWDigestBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_PrimaryWDigest(struct ndr_print *ndr, const char *name, int flags, const struct decode_PrimaryWDigest *r)
{
	ndr_print_struct(ndr, name, "decode_PrimaryWDigest");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_PrimaryWDigest");
		ndr->depth++;
		ndr_print_package_PrimaryWDigestBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_PrimaryWDigest");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_trustAuthInOut(struct ndr_push *ndr, int flags, const struct decode_trustAuthInOut *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_trustAuthInOutBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_trustAuthInOut(struct ndr_pull *ndr, int flags, struct decode_trustAuthInOut *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_trustAuthInOutBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_trustAuthInOut(struct ndr_print *ndr, const char *name, int flags, const struct decode_trustAuthInOut *r)
{
	ndr_print_struct(ndr, name, "decode_trustAuthInOut");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_trustAuthInOut");
		ndr->depth++;
		ndr_print_trustAuthInOutBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_trustAuthInOut");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_DsCompressed(struct ndr_push *ndr, int flags, const struct decode_DsCompressed *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_DsCompressedBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_DsCompressed(struct ndr_pull *ndr, int flags, struct decode_DsCompressed *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_DsCompressedBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_DsCompressed(struct ndr_print *ndr, const char *name, int flags, const struct decode_DsCompressed *r)
{
	ndr_print_struct(ndr, name, "decode_DsCompressed");
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_DsCompressed");
		ndr->depth++;
		ndr_print_DsCompressedBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_DsCompressed");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static const struct ndr_interface_call drsblobs_calls[] = {
	{
		"decode_replPropertyMetaData",
		sizeof(struct decode_replPropertyMetaData),
		(ndr_push_flags_fn_t) ndr_push_decode_replPropertyMetaData,
		(ndr_pull_flags_fn_t) ndr_pull_decode_replPropertyMetaData,
		(ndr_print_function_t) ndr_print_decode_replPropertyMetaData,
		false,
	},
	{
		"decode_replUpToDateVector",
		sizeof(struct decode_replUpToDateVector),
		(ndr_push_flags_fn_t) ndr_push_decode_replUpToDateVector,
		(ndr_pull_flags_fn_t) ndr_pull_decode_replUpToDateVector,
		(ndr_print_function_t) ndr_print_decode_replUpToDateVector,
		false,
	},
	{
		"decode_repsFromTo",
		sizeof(struct decode_repsFromTo),
		(ndr_push_flags_fn_t) ndr_push_decode_repsFromTo,
		(ndr_pull_flags_fn_t) ndr_pull_decode_repsFromTo,
		(ndr_print_function_t) ndr_print_decode_repsFromTo,
		false,
	},
	{
		"decode_partialAttributeSet",
		sizeof(struct decode_partialAttributeSet),
		(ndr_push_flags_fn_t) ndr_push_decode_partialAttributeSet,
		(ndr_pull_flags_fn_t) ndr_pull_decode_partialAttributeSet,
		(ndr_print_function_t) ndr_print_decode_partialAttributeSet,
		false,
	},
	{
		"decode_prefixMap",
		sizeof(struct decode_prefixMap),
		(ndr_push_flags_fn_t) ndr_push_decode_prefixMap,
		(ndr_pull_flags_fn_t) ndr_pull_decode_prefixMap,
		(ndr_print_function_t) ndr_print_decode_prefixMap,
		false,
	},
	{
		"decode_ldapControlDirSync",
		sizeof(struct decode_ldapControlDirSync),
		(ndr_push_flags_fn_t) ndr_push_decode_ldapControlDirSync,
		(ndr_pull_flags_fn_t) ndr_pull_decode_ldapControlDirSync,
		(ndr_print_function_t) ndr_print_decode_ldapControlDirSync,
		false,
	},
	{
		"decode_supplementalCredentials",
		sizeof(struct decode_supplementalCredentials),
		(ndr_push_flags_fn_t) ndr_push_decode_supplementalCredentials,
		(ndr_pull_flags_fn_t) ndr_pull_decode_supplementalCredentials,
		(ndr_print_function_t) ndr_print_decode_supplementalCredentials,
		false,
	},
	{
		"decode_Packages",
		sizeof(struct decode_Packages),
		(ndr_push_flags_fn_t) ndr_push_decode_Packages,
		(ndr_pull_flags_fn_t) ndr_pull_decode_Packages,
		(ndr_print_function_t) ndr_print_decode_Packages,
		false,
	},
	{
		"decode_PrimaryKerberos",
		sizeof(struct decode_PrimaryKerberos),
		(ndr_push_flags_fn_t) ndr_push_decode_PrimaryKerberos,
		(ndr_pull_flags_fn_t) ndr_pull_decode_PrimaryKerberos,
		(ndr_print_function_t) ndr_print_decode_PrimaryKerberos,
		false,
	},
	{
		"decode_PrimaryCLEARTEXT",
		sizeof(struct decode_PrimaryCLEARTEXT),
		(ndr_push_flags_fn_t) ndr_push_decode_PrimaryCLEARTEXT,
		(ndr_pull_flags_fn_t) ndr_pull_decode_PrimaryCLEARTEXT,
		(ndr_print_function_t) ndr_print_decode_PrimaryCLEARTEXT,
		false,
	},
	{
		"decode_PrimaryWDigest",
		sizeof(struct decode_PrimaryWDigest),
		(ndr_push_flags_fn_t) ndr_push_decode_PrimaryWDigest,
		(ndr_pull_flags_fn_t) ndr_pull_decode_PrimaryWDigest,
		(ndr_print_function_t) ndr_print_decode_PrimaryWDigest,
		false,
	},
	{
		"decode_trustAuthInOut",
		sizeof(struct decode_trustAuthInOut),
		(ndr_push_flags_fn_t) ndr_push_decode_trustAuthInOut,
		(ndr_pull_flags_fn_t) ndr_pull_decode_trustAuthInOut,
		(ndr_print_function_t) ndr_print_decode_trustAuthInOut,
		false,
	},
	{
		"decode_DsCompressed",
		sizeof(struct decode_DsCompressed),
		(ndr_push_flags_fn_t) ndr_push_decode_DsCompressed,
		(ndr_pull_flags_fn_t) ndr_pull_decode_DsCompressed,
		(ndr_print_function_t) ndr_print_decode_DsCompressed,
		false,
	},
	{ NULL, 0, NULL, NULL, NULL, false }
};

static const char * const drsblobs_endpoint_strings[] = {
	"ncacn_np:[\\pipe\\drsblobs]", 
};

static const struct ndr_interface_string_array drsblobs_endpoints = {
	.count	= 1,
	.names	= drsblobs_endpoint_strings
};

static const char * const drsblobs_authservice_strings[] = {
	"host", 
};

static const struct ndr_interface_string_array drsblobs_authservices = {
	.count	= 1,
	.names	= drsblobs_authservice_strings
};


const struct ndr_interface_table ndr_table_drsblobs = {
	.name		= "drsblobs",
	.syntax_id	= {
		{0x12345778,0x1234,0xabcd,{0x00,0x01},{0x00,0x00,0x00,0x01}},
		NDR_DRSBLOBS_VERSION
	},
	.helpstring	= NDR_DRSBLOBS_HELPSTRING,
	.num_calls	= 13,
	.calls		= drsblobs_calls,
	.endpoints	= &drsblobs_endpoints,
	.authservices	= &drsblobs_authservices
};

