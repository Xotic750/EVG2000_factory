/* header auto-generated by pidl */

#include <stdint.h>

#include "librpc/gen_ndr/drsuapi.h"
#include "librpc/gen_ndr/misc.h"
#ifndef _HEADER_drsblobs
#define _HEADER_drsblobs

#define SUPPLEMENTAL_CREDENTIALS_PREFIX	( "                                                " )
enum drsuapi_DsAttributeId;

struct replPropertyMetaData1 {
	enum drsuapi_DsAttributeId attid;
	uint32_t version;
	NTTIME originating_change_time;
	struct GUID originating_invocation_id;
	uint64_t originating_usn;
	uint64_t local_usn;
};

struct replPropertyMetaDataCtr1 {
	uint32_t count;
	uint32_t reserved;
	struct replPropertyMetaData1 *array;
};

union replPropertyMetaDataCtr {
	struct replPropertyMetaDataCtr1 ctr1;/* [case] */
}/* [nodiscriminant] */;

struct replPropertyMetaDataBlob {
	uint32_t version;
	uint32_t reserved;
	union replPropertyMetaDataCtr ctr;/* [switch_is(version)] */
}/* [public] */;

struct replUpToDateVectorCtr1 {
	uint32_t count;
	uint32_t reserved;
	struct drsuapi_DsReplicaCursor *cursors;
};

struct replUpToDateVectorCtr2 {
	uint32_t count;
	uint32_t reserved;
	struct drsuapi_DsReplicaCursor2 *cursors;
};

union replUpToDateVectorCtr {
	struct replUpToDateVectorCtr1 ctr1;/* [case] */
	struct replUpToDateVectorCtr2 ctr2;/* [case(2)] */
}/* [nodiscriminant] */;

struct replUpToDateVectorBlob {
	uint32_t version;
	uint32_t reserved;
	union replUpToDateVectorCtr ctr;/* [switch_is(version)] */
}/* [public] */;

struct repsFromTo1OtherInfo {
	uint32_t __dns_name_size;/* [value(strlen(dns_name)+1)] */
	const char *dns_name;/* [charset(DOS)] */
}/* [gensize,public] */;

struct repsFromTo1 {
	uint32_t blobsize;/* [value(ndr_size_repsFromTo1(this,ndr->flags)+8)] */
	uint32_t consecutive_sync_failures;
	NTTIME last_success;
	NTTIME last_attempt;
	WERROR result_last_attempt;
	struct repsFromTo1OtherInfo *other_info;/* [relative] */
	uint32_t other_info_length;/* [value(ndr_size_repsFromTo1OtherInfo(other_info,ndr->flags))] */
	uint32_t replica_flags;
	uint8_t schedule[84];
	uint32_t reserved;
	struct drsuapi_DsReplicaHighWaterMark highwatermark;
	struct GUID source_dsa_obj_guid;
	struct GUID source_dsa_invocation_id;
	struct GUID transport_guid;
}/* [gensize,public,flag(LIBNDR_PRINT_ARRAY_HEX)] */;

union repsFromTo {
	struct repsFromTo1 ctr1;/* [case] */
}/* [nodiscriminant] */;

struct repsFromToBlob {
	uint32_t version;
	uint32_t reserved;
	union repsFromTo ctr;/* [switch_is(version)] */
}/* [public] */;

struct partialAttributeSetCtr1 {
	uint32_t count;
	enum drsuapi_DsAttributeId *array;
};

union partialAttributeSetCtr {
	struct partialAttributeSetCtr1 ctr1;/* [case] */
}/* [nodiscriminant] */;

struct partialAttributeSetBlob {
	uint32_t version;
	uint32_t reserved;
	union partialAttributeSetCtr ctr;/* [switch_is(version)] */
}/* [public] */;

enum prefixMapVersion
#ifndef USE_UINT_ENUMS
 {
	PREFIX_MAP_VERSION_DSDB=0x44534442
}
#else
 { __donnot_use_enum_prefixMapVersion=0x7FFFFFFF}
#define PREFIX_MAP_VERSION_DSDB ( 0x44534442 )
#endif
;

union prefixMapCtr {
	struct drsuapi_DsReplicaOIDMapping_Ctr dsdb;/* [case(PREFIX_MAP_VERSION_DSDB)] */
}/* [nodiscriminant] */;

struct prefixMapBlob {
	enum prefixMapVersion version;
	uint32_t reserved;
	union prefixMapCtr ctr;/* [switch_is(version)] */
}/* [public] */;

union ldapControlDirSyncExtra {
	struct replUpToDateVectorBlob uptodateness_vector;/* [default] */
}/* [gensize,nodiscriminant] */;

struct ldapControlDirSyncBlob {
	uint32_t u1;/* [value(3)] */
	NTTIME time;
	uint32_t u2;
	uint32_t u3;
	uint32_t extra_length;/* [value(ndr_size_ldapControlDirSyncExtra(&extra,extra.uptodateness_vector.version,0))] */
	struct drsuapi_DsReplicaHighWaterMark highwatermark;
	struct GUID guid1;
	union ldapControlDirSyncExtra extra;/* [switch_is(extra_length)] */
};

struct ldapControlDirSyncCookie {
	const char *msds;/* [value("MSDS"),charset(DOS)] */
	struct ldapControlDirSyncBlob blob;/* [subcontext(0)] */
}/* [relative_base,public] */;

struct supplementalCredentialsPackage {
	uint16_t name_len;/* [value(2*strlen_m(name))] */
	uint16_t data_len;/* [value(strlen(data))] */
	uint16_t reserved;
	const char *name;/* [charset(UTF16)] */
	const char *data;/* [charset(DOS)] */
};

enum supplementalCredentialsSignature
#ifndef USE_UINT_ENUMS
 {
	SUPPLEMENTAL_CREDENTIALS_SIGNATURE=0x0050
}
#else
 { __donnot_use_enum_supplementalCredentialsSignature=0x7FFFFFFF}
#define SUPPLEMENTAL_CREDENTIALS_SIGNATURE ( 0x0050 )
#endif
;

struct supplementalCredentialsSubBlob {
	const char *prefix;/* [value(SUPPLEMENTAL_CREDENTIALS_PREFIX),charset(UTF16)] */
	enum supplementalCredentialsSignature signature;/* [value(SUPPLEMENTAL_CREDENTIALS_SIGNATURE)] */
	uint16_t num_packages;
	struct supplementalCredentialsPackage *packages;
}/* [gensize] */;

struct supplementalCredentialsBlob {
	uint32_t unknown1;/* [value(0)] */
	uint32_t __ndr_size;/* [value(ndr_size_supplementalCredentialsSubBlob(&sub,ndr->flags))] */
	uint32_t unknown2;/* [value(0)] */
	struct supplementalCredentialsSubBlob sub;/* [subcontext_size(__ndr_size),subcontext(0)] */
	uint8_t unknown3;/* [value(0)] */
}/* [public] */;

struct package_PackagesBlob {
	const char ** names;/* [flag(LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING)] */
}/* [public] */;

struct package_PrimaryKerberosString {
	uint16_t length;/* [value(2*strlen_m(string))] */
	uint16_t size;/* [value(2*strlen_m(string))] */
	const char * string;/* [relative,subcontext_size(size),subcontext(0),flag(LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING)] */
};

struct package_PrimaryKerberosKey3 {
	uint16_t reserved1;/* [value(0)] */
	uint16_t reserved2;/* [value(0)] */
	uint32_t reserved3;/* [value(0)] */
	uint32_t keytype;
	uint32_t value_len;/* [value((value?value->length:0))] */
	DATA_BLOB *value;/* [relative,subcontext_size(value_len),subcontext(0),flag(LIBNDR_FLAG_REMAINING)] */
};

struct package_PrimaryKerberosCtr3 {
	uint16_t num_keys;
	uint16_t num_old_keys;
	struct package_PrimaryKerberosString salt;
	struct package_PrimaryKerberosKey3 *keys;
	struct package_PrimaryKerberosKey3 *old_keys;
	uint32_t padding1;/* [value(0)] */
	uint32_t padding2;/* [value(0)] */
	uint32_t padding3;/* [value(0)] */
	uint32_t padding4;/* [value(0)] */
	uint32_t padding5;/* [value(0)] */
};

struct package_PrimaryKerberosKey4 {
	uint16_t reserved1;/* [value(0)] */
	uint16_t reserved2;/* [value(0)] */
	uint32_t reserved3;/* [value(0)] */
	uint32_t iteration_count;
	uint32_t keytype;
	uint32_t value_len;/* [value((value?value->length:0))] */
	DATA_BLOB *value;/* [relative,subcontext_size(value_len),subcontext(0),flag(LIBNDR_FLAG_REMAINING)] */
};

struct package_PrimaryKerberosCtr4 {
	uint16_t num_keys;
	uint16_t num_service_keys;/* [value(0)] */
	uint16_t num_old_keys;
	uint16_t num_older_keys;
	struct package_PrimaryKerberosString salt;
	uint32_t default_iteration_count;
	struct package_PrimaryKerberosKey4 *keys;
	struct package_PrimaryKerberosKey4 *service_keys;
	struct package_PrimaryKerberosKey4 *old_keys;
	struct package_PrimaryKerberosKey4 *older_keys;
};

union package_PrimaryKerberosCtr {
	struct package_PrimaryKerberosCtr3 ctr3;/* [case(3)] */
	struct package_PrimaryKerberosCtr4 ctr4;/* [case(4)] */
}/* [nodiscriminant] */;

struct package_PrimaryKerberosBlob {
	uint16_t version;
	uint16_t flags;/* [value(0)] */
	union package_PrimaryKerberosCtr ctr;/* [switch_is(version)] */
}/* [public] */;

struct package_PrimaryCLEARTEXTBlob {
	const char * cleartext;/* [flag(LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING)] */
}/* [public] */;

struct package_PrimaryWDigestHash {
	uint8_t hash[16];
}/* [flag(LIBNDR_PRINT_ARRAY_HEX)] */;

struct package_PrimaryWDigestBlob {
	uint16_t unknown1;/* [value(0x31)] */
	uint8_t unknown2;/* [value(0x01)] */
	uint8_t num_hashes;
	uint32_t unknown3;/* [value(0)] */
	uint64_t uuknown4;/* [value(0)] */
	struct package_PrimaryWDigestHash *hashes;
}/* [public] */;

struct trustAuthInOutSecret1 {
	NTTIME time1;
	uint32_t unknown1;
	DATA_BLOB value;
	DATA_BLOB _pad;/* [flag(LIBNDR_FLAG_ALIGN4)] */
};

struct trustAuthInOutCtr1 {
	struct trustAuthInOutSecret1 *value1;/* [relative] */
	struct trustAuthInOutSecret1 *value2;/* [relative] */
};

struct trustAuthInOutSecret2V1 {
	NTTIME time1;
	uint32_t unknown1;
	DATA_BLOB value;
	NTTIME time2;
	uint32_t unknown2;
	uint32_t unknown3;
	uint32_t unknown4;
	DATA_BLOB _pad;/* [flag(LIBNDR_FLAG_ALIGN4)] */
};

struct trustAuthInOutSecret2V2 {
	NTTIME time1;
	uint32_t unknown1;
	DATA_BLOB value;
	NTTIME time2;
	uint32_t unknown2;
	uint32_t unknown3;
	DATA_BLOB _pad;/* [flag(LIBNDR_FLAG_ALIGN4)] */
};

struct trustAuthInOutCtr2 {
	struct trustAuthInOutSecret2V1 *value1;/* [relative] */
	struct trustAuthInOutSecret2V2 *value2;/* [relative] */
};

union trustAuthInOutCtr {
	struct trustAuthInOutCtr1 ctr1;/* [case] */
	struct trustAuthInOutCtr2 ctr2;/* [case(2)] */
}/* [nodiscriminant] */;

struct trustAuthInOutBlob {
	uint32_t version;
	union trustAuthInOutCtr ctr;/* [switch_is(version)] */
}/* [public] */;

struct DsCompressedChunk {
	uint32_t marker;
	DATA_BLOB data;
}/* [public] */;

struct DsCompressedBlob {
	struct DsCompressedChunk chunks[5];
}/* [public] */;


struct decode_replPropertyMetaData {
	struct {
		struct replPropertyMetaDataBlob blob;
	} in;

};


struct decode_replUpToDateVector {
	struct {
		struct replUpToDateVectorBlob blob;
	} in;

};


struct decode_repsFromTo {
	struct {
		struct repsFromToBlob blob;
	} in;

};


struct decode_partialAttributeSet {
	struct {
		struct partialAttributeSetBlob blob;
	} in;

};


struct decode_prefixMap {
	struct {
		struct prefixMapBlob blob;
	} in;

};


struct decode_ldapControlDirSync {
	struct {
		struct ldapControlDirSyncCookie cookie;
	} in;

};


struct decode_supplementalCredentials {
	struct {
		struct supplementalCredentialsBlob blob;
	} in;

};


struct decode_Packages {
	struct {
		struct package_PackagesBlob blob;
	} in;

};


struct decode_PrimaryKerberos {
	struct {
		struct package_PrimaryKerberosBlob blob;
	} in;

};


struct decode_PrimaryCLEARTEXT {
	struct {
		struct package_PrimaryCLEARTEXTBlob blob;
	} in;

};


struct decode_PrimaryWDigest {
	struct {
		struct package_PrimaryWDigestBlob blob;
	} in;

};


struct decode_trustAuthInOut {
	struct {
		struct trustAuthInOutBlob blob;
	} in;

};


struct decode_DsCompressed {
	struct {
		struct DsCompressedBlob blob;
	} in;

};

#endif /* _HEADER_drsblobs */
